Commands 
1. fastapi dev main.py
2. fastapi --help
3. psql -U postgres
4. pip install asyncpg
5. alembic init -t async migrations
6. alembic revision --autogenerate -m "init"
7. alembic upgrade head
8. alembic revision --autogenerate -m "auto password hash"

Type "help" for help.


The basic timeline:
    1. Basics of fastapi
    2. Basic CRUD(Without DB)
    3. CRUD(With DB)
    4. Adding User model
    5. Adding Authentication to user model
    6. JWT Authentication

postgres=# CREATE USER sindh WITH PASSWORD 'Sindhu';

CREATE ROLE
postgres=#


crud
create, read, update, delete

resource-> Provides or allows you to manipukate data


Data bases with sql model

Fast api supports varios types of databases SQ, No sql, relational etc


Why are we using PostgreSQL?
- This is used in relational database 
- Free and open-source relational database management system
- It offers nuerous benefits


Whats ORM?
An Object Relational Mapper (ORM), translates between a programming language, and database like PostgreSQL

Mapping Onjects to tables:
    - Create Python classes to represent the table
    - Each object of this class correspons to a row in database table
    - ORM translates the actions into appropriate SQL queries

SQL- Alchemy:
    - Most popular ORM 
    - Seamless integration with pydantic 

Observation:
    The errors I encountered are mostly due to the
    validation error

Completed crud


Create User Authentication model:

Migrations:
    Make changes to the database without having to
    loose data


 alembic init -t async migrations:
    After this a new folder called migrations is created it has
    1. Version:
        This folder holds the files that track migrations and database changes 
        
After executing the aembic things
1. In the bookly_db 3 tables/relations are created
    i. alembic_version:
        This maintains the record of migrations
    ii. books
    iii. users


NOw, User Account Creation


 Why do we need bcrypt?
When users create passwords (e.g., for logging into a website), we should never store their actual passwords directly.
If someone hacks the database, they shouldn't see plain-text passwords!

Instead:

We hash the password (convert it into a scrambled form).

We store only the hash.

Later, when the user logs in, we hash their entered password again and compare the hashes, not the raw passwords.

⚙️ What is bcrypt doing exactly?
It takes a password (like mypassword123)

It adds a "salt" (random extra characters to make it unique)

It runs multiple rounds of hashing to make it very slow for attackers to crac


JWT Authentcation

- We shall allow users ti identify themselves so that they can gain acees to the aplication

- this is a stateless client-side form of authentication where user indentify themselves through the use of JWT's

- JWT are essentially credentials that contain informaton about user 
- This information is encoded in JSON format, This token is digitally designed, ensuring authencity and integrity


Componentsof JWT:
    JSON web token
    JWT has three parts 
    - Header:  specifies the algorithm used (e.g., HS256)
    - Payload: the actual data (like user ID, email)
    - Signature: 

    - Seperated by a period sign

 How JWT Authentication Works:
    User logs in with username and password.

    If credentials are valid, the server creates a JWT and sends it back to the client.

    The client stores the token (usually in local storage or cookies).

    For future requests, the client sends the token in the Authorization header:

    makefile
    Copy code
    Authorization: Bearer <JWT>
    The server verifies the token using its secret key and, if valid, processes the request.
Advantages
    Stateless (no need to store sessions on the server)

    Secure (if properly implemented)

    Scalable (easy to use in distributed systems)

How JWT Auth works:
    - The user logs into application
    - Server verifis user's credentials
    - Upon sucessful login, server generates a JWT user claims.
    - For future requests, client sends the JWT in HTTP header.

Some benefit of JWT's:
    - Can be send via URL, PoST request body, or header
    - They are self-contained
    - They are secure
    - They can be used across different domains
    

 #  Access Token:
        Purpose: Used to access protected routes or resources.

        Short-lived: Typically valid for a short time (e.g., 15 minutes to 1 hour).

        Sent with each request: Clients send it in the header (Authorization: Bearer <token>) to prove they are authenticated.

        Smaller risk: Since it expires quickly, even if stolen, damage is limited.

# Refresh Token:
        Purpose: Used to get a new access token without logging in again.

        Long-lived: Can last days, weeks, or more.

        Stored securely: Should not be sent with every request—store it securely (e.g., HTTP-only cookie).

        Used when access token expires: Client sends it to the server to request a new access token.


`JWT Authentication (HTTP Bearer Authentication)` 

- Limiting the access to the users who doonot have tokens

`JWT Authentication (Creating New Access Tokens)`



ACcess vs refresh tokens
User logs in → receives access token and refresh token.

Access token is used in API requests.

When the access token expires, the refresh token is sent to the server to get a new access token without logging in again.

What is Dependency Injection?
It’s a design pattern where objects (like functions, classes, or values) are provided to other parts of the application rather than hardcoded. FastAPI uses this to reuse logic like authentication, database sessions, or parameter validation.


`JWT Authetication(Revoking User Tokens with Redis)`
- 5:50:07
- JWT are stateless, so revoking them (eg on logout) requires a blacklist.
- Redis fast-in-memory operations

Workflow
1. User Login --> Issue JWT
2. Logout
3. Every Authentticated Request

